가상 면접 사례로 배우는 대규모 시스템 설계 기초 1장 정리

## 단일 서버
모든 컴포넌트가 단 한대에 서버에서 실행되는 간단한 시스템 부터 설계한다.

클라이언트 DNS에 도메인 이름으로 IP 질의 -> 클라이언트는 DNS 조회 결과로 IP 얻어옴 -> 
얻어온 IP 주소로 클라이언트는 HTTP 요청 전달 -> 웹서버는 클라이언트에게 HTML 웹페이지 전달

## 데이터베이스

사용자가 늘면 단일서버로는 충분하지 않아서 웹/모바일 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)을 분리한다.
그렇다면 그 각각을 독립적으로 확장해 나갈 수 있다.

#### 어떤 데이터베이스를 사용할것인가?

관계형 데이터베이스 :  MySQL, 오라클, PostgreSQL 등
비-관계형 데이터베이스 (NoSQL) :  CouchDB, Neo4j, Cassandra, HBase, MongoDB, Amazon DynamoDB 등

NoSQL은 다시 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소 네 부류로 나뉘어진다고 한다.

언제 비-관계형 데이터베이스를 사용할 수 있을까?

* 아주 낮은 응답 지연시간이 요구될 때
* 다루는 데이터가 비정형(unstructured)라서 관계형 데이터가 아닐 때
* 데이터를 직렬화하거나 역직렬화만 하면 될 때
* 아주 많은 양의 데이터를 저장할 필요가 있을 때

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장(scale-up)
서버에 고사양 자원을 추가(더 좋은 CPU, 더 많은 램)하는 행위
### 수평적 규모 확장(scale-out)
더 많은 서버를 추가하여 성능을 개선하는 행위

트래픽이 적을때는 수직적 확장이 좋은 선택이다.

하지만, 한대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없다.
단일 컴퓨팅 파워에는 한계가 존재하기 때문이다.
또, 장애에 대한 자동복구(failover)나 다중화(redundancdy) 방안을 제시하지 않는다. 
서버에 장애가 발생하면, 모든 웹사이트, 앱은 서비스가 중단된다. 
이런 단점으로 대규모 애플리케이션에는 수평적 규모 확장법이 더 적절하다.

## 로드밸런서
부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산해주는 요소

사용자는 웹서버 대신 로드밸런서의 공개 IP 주소로 접속한다.
웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.
일반적으로 보안을 위해 서버간 통신에는 사설 IP 주소를 사용한다. 
따라서, 로드 밸런서와 웹 서버는 이 사설 주소를 사용하여 통신한다.

부하 분산 집합에 웹 서버를 하나 더 추가
-> 자동 복구하지 못하는 문제(no failover)가 해소 , 웹 계층의 가용성(availability)은 향상

웹 계층은 어느정도 개선됐는데, 데이터베이스 서버는 아직 하나이다. 
자동 복구나 다중화를 지원하지 않는다. 
데이터베이스 다중화는 이런 문제를 해결한다.

## 데이터베이스 다중화 

많은 데이터베이스 관리 시스템이 다중화를 지원한다.
주(master)-부(slave) 관계를 설정하고, 데이터 원본은 주 서버에, 사본은 부 서버에 저장한다.

대부분의 어플리케이션은 읽기 연산의 비중이 쓰기 연산보다 많다.
주 데이터베이스 서버보다 부 데이터베이스 서버 수가 더 많다.

#### 데이터베이스를 다중화하면 얻는 이점은 무엇일까?

더 나은 성능 , 안정성 , 가용성

## 캐시
캐시를 사용하면 응답시간(latency)을 개선할 수 있다. 

이때 캐시란, 값 비싼 연산결과나 자주 참조되는 데이터를 메모리에 보관하고, 뒤 이은 요청부터 빨리 처리될 수 있도록 하는 저장소이다.

애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 따라 크게 좌우된다.

캐시 계층(cache tier)는 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨신 빠르다.
데이터베이스는 데이터를 디스크에 저장하고, 캐시는 램에 저장하기 때문이다.

#### 별도의 캐시 계층을 두면 이점은 무엇일까?

성능이 개선 ,  데이터베이스 부하가 줄어듦 , 캐시 계층을 독립적으로 확장

#### 읽기 주도형 캐시 전략(read-through caching strategy)
웹 서버는 캐시 서버에 데이터가 있다면 캐시 서버에서 데이터를 읽는다. 
없다면 데이터베이스에서 데이터를 읽고, 캐시에 저장한뒤 클라이언트에 반환한다.

#### 캐시 사용시 유의점
* 캐시는 어떤 상황에 바람직한가?

데이터 갱신은 자주 일어나지 않지만, 참조가 빈번할 때

* 어떤 데이터를 캐시에 두어야 하는가?

영속적으로 보관할 데이터를 캐시에 두는 것은 바람직 하지 않다. 캐시는 휘발성 메모리에 데이터를 저장하기 때문. 중요한 데이터는 영속성 저장소(persistent data store)에 두어야한다.

* 캐시에 보관된 데이터는 어떻게 만료(expire)되는가?

적절한 만료 정책을 마련해두는것이 좋다. 만료된 데이터는 캐시에서 삭제해야한다. 만료 정책이 없으면 데이터가 캐시에 계속 남는다. 만료 기한이 너무 짧으면, 데이터베이스를 너무 자주 읽게 되므로 캐시를 두는 의미가 퇴색될 수 있다. 만료 기한이 너무 길면 실제 데이터와 캐시가 차이가날 가능성이 있으므로 주의한다.

* 일관성은 어떻게 유지되는가?

일관성이란 데이터의 원본과 캐시된 사본이 같은지의 여부이다. 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성이 깨질 수 있다. 원본 데이터 갱신을 성공하고, 캐시 갱신에는 실패하였을 때 이 두 연산이 단일 트랜잭션으로 묶이지 않았다면 원본과 캐시의 일관성이 깨진다. 여러 지역에 걸쳐 시스템을 확장하는 경우 캐시와 저장소 사이의 일관성을 유지하는것은 어려운 문제이다.

* 장애에는 어떻게 대처할 것인가?

캐시 서버를 한대만 두면 단일 장애 지점(Single Point of Failure, SPOF)가 될 수 있다. SPOF를 피하려면, 여러 지역에 걸쳐 캐시 서버를 분산해야한다.

* 캐시 메모리는 얼마나 크게 잡을 것인가?

캐시 메모리가 너무 작다면, 액세스 패턴에 따라 데이터가 캐시 메모리에서 너무 자주 밀려나버려(eviction) 성능이 떨어지게된다. 이를 막을 한가지 방법은 캐시 메모리를 과할당(overprovision) 하는 것이다. 갑자기 캐시에 보관할 데이터가 많아졌을 때 생길 문제를 방지할 수 있다.

* 데이터 방출(eviction) 정책은 무엇인가?

캐시가 꽉 차버린 상태에서 추가로 데이터를 넣어야한다면 기존 데이터를 내보내야한다. 이를 데이터 방출 정책이라고 하는데, 가장 널리 쓰이는건 마지막으로 사용된 시점이 가장 오래된 데이터를 먼저 내보내는 LRU(Least Recently Used)이다. 다른 정책으로는 사용된 빈도가 가장 낮은 데이터를 내보내는 LFU(Least Frequently Used), 가장 먼저 캐시에 들어온 데이터를 가장 먼저 내보내는 정책인 FIFO(First In First Out)같은것이 있다.

## 콘텐츠 전송 네트워크(CDN)
CDN은 정적 콘텐츠 (이미지, 비디오, CSS, Javascript) 를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크이다. 
사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.

#### CDN의 동작 과정
1. 사용자가 이미지 URL을 이용해 이미지에 접근한다. 이 URL의 도메인은 CDN 서비스 사업자가 제공한다.
2. CDN 서버에 해당 이미지가 없는 경우 CDN 서버는 원본 서버에 요청해 파일을 가져온다. 원본 서버는 웹 서버일수도, S3 같은 온라인 저장소일수도 있다.
3. 원본 서버가 CDN 서버에 파일을 반환한다. HTTP 응답 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지 나타내는 TTL(Time-To-Live) 값이 들어있다.
4. CDN서버는 파일을 캐시하고 사용자에게 반환한다. 이 이미지 파일은 TTL에 명시된 시간만큼 캐시된다.
5. 다른 사용자가 동일한 이미지를 CDN 서버에 요청한다.
6. 해당 이미지가 만료되지 않았다면 CDN 서버가 캐시해둔 파일을 반환한다.

#### CDN 사용시 고려해야 할 사항

비용
적절한 만료 시한 설정
CDN 장애에 대한 대처 방안
콘텐츠 무효화(invalidation) 방법

## 무상태(stateless) 웹 계층

이를 위해서는 상태 정보를 웹 계층에서 제거하여야 한다. 
바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.
이렇게 구성된 웹계층을 무상태 웹 계층이라고 부른다.

#### 상태 정보 의존적인 아키텍처

상태정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유(쿠키와 세션등을 사용하여)되도록 한다. 무상태 서버에는 이런 장치가 없다.

## 무상태 아키텍처

무상태 아키텍처는 상태 정보를 별도의 공유 저장소(shared storage)로부터 데이터를 저장하고 가져온다.
즉, 상태 정보는 웹 서버로부터 물리적으로 분리되어 있다. 이런 구조는 단순하고, 안정적이고, 규모 확장이 쉽다.

## 데이터 센터

가용성을 높이고 전세계 어디서든 쾌적하게 사용하기 위해 데이터 센터(data center)를 지원하는것이 필수이다.
지리적으로 분리된 두개의 데이터 센터가 있다고 가정하자. 장애가 없는 상황에서 사용자는 가장 가까운 데이터센터로 라우팅된다. 

이 절차를 지리적 라우팅(geoDNS-routing 또는 geo-routing) 이라고 한다.

만약 데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽은 장애가 발생하지 않은 데이터 센터로 향한다.

##### 다중 데이터센터 아키텍처를 만들기 위해서는 몇 가지 기술적 난제를 해결해야한다.
트래픽 우회
데이터 동기화
테스트와 배포

## 메시지 큐

시스템을 더 큰 규모로 확장하려면, 시스템의 컴포넌트를 분리(느슨한 결합, loose coupling)하고 각기 독립적으로 확장될 수 있도록 해야한다. 메시지큐는 많은 실제 분산 시스템이 이 문제를 풀기위해 사용하는 핵심적인 전략이다.

메시지 큐는 비동기 통신을 지원하는 컴포넌트이다. 메시지큐는 무손실을 보장하는 특징이 있는데, 이는 메시지 큐에 한번 저장된 메시지는 소비자가 꺼낼때 까지 안전히 보관된다는 점이다. 메시지큐는 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.

생산자 또는 발행자(producer/publisher)라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다. 메시지 큐에는 소비자 혹은 구독자(consumer/subscriber)라고 불리는 서비스 또는 서버가 연결되어 있는데, 메시지를 받고 동작을 수행하는 역할을 한다.

메시지 큐를 사용하면 서비스 또는 서버 간 결합이 느슨해져, 규모 확장성이 보장되어야 하는 안정적인 애플리케이션을 구성하기 좋다. 또, 결함에 대한 내성을 높여준다.

생산자는 소비자가 다운되어 있을때도 메시지를 발행할 수 있고, 반대로 소비자는 생산자 서비스가 다운되어 있더라도 메시지를 수신할 수 있다.

## 로그, 메트릭 그리고 자동화

소규모 서비스에서는 로그, 메트릭(metric), 자동화(automation)은 좋지만 필수는 아니다. 하지만 사업 규모가 커지면 이런 도구에도 투자해야한다.

##### 로그
에러 로그를 모니터링 하는 것은 중요하다. 시스템의 오류와 문제를 보다 쉽게 찾아낼 수 있도록 하기 때문이다. 서버 단위로 로그를 모니터링하는 것도 좋지만, 로그를 하나로 모아주는 도구를 활용하면 더 편리하게 검색, 조회 할 수 있다.

##### 메트릭
메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을수도 있고, 시스템의 현재 상태를 손쉽게 파악할 수 도 있다.
호스트 단위 메트릭: CPU, 메모리, 디스크 I/O에 관한 메트릭
종합(aggregated) 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
핵심 비즈니스 메트릭: 일별 활성 사용자(daily active user), 수익, 재방문(retention) 같은 것들

##### 자동화
시스템이 크고 복잡해지면, 생산성을 위해 자동화 도구를 활용해야한다. 빌드, 테스트, 배포 등의 절차를 자동화할 수 있다.

## 데이터베이스의 규모 확장

### 수직적 확장
데이터베이스 서버의 CPU, RAM, 디스크와 같은 자원을 증설하는 방법이다. 수직적 접근법에는 몇가지 심각한 약점이 있다.

* 서버 하드웨어를 무한 증설할 수 없으므로 한계가 존재한다.
* 하나의 데이터베이스를 수직 확장하면 SPOF로 인한 위험성이 크다.
* 고성능 서버로 갈수록 가격이 올라가므로 비용이 많이 발생한다.

#### 수평적 확장

데이터베이스의 수평적 확장을 샤딩(sharding)이라고 부른다. 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있다.

샤딩은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할한다.
모든 샤드는 같은 스키마를 사용하지만, 샤드에 보관되는 데이터사이에는 중복이 없다.


